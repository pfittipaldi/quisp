//
// Generated file, do not edit! Created by opp_msgtool 6.0 from messages/gatedqueue_messages.msg.
//

#ifndef __MESSAGES_GATEDQUEUE_MESSAGES_M_H
#define __MESSAGES_GATEDQUEUE_MESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace messages {

class GQ_ctrl;
class NeighborTable;
class Header;
class OspfPacket;
class OspfHelloPacket;

}  // namespace messages


namespace messages {

/**
 * Class generated from <tt>messages/gatedqueue_messages.msg:3</tt> by opp_msgtool.
 * <pre>
 * packet GQ_ctrl
 * {
 *     bool ctrl_signal;
 *     bool is_copy = false;
 * }
 * </pre>
 */
class GQ_ctrl : public ::omnetpp::cPacket
{
  protected:
    bool ctrl_signal = false;
    bool is_copy = false;

  private:
    void copy(const GQ_ctrl& other);

  protected:
    bool operator==(const GQ_ctrl&) = delete;

  public:
    GQ_ctrl(const char *name=nullptr, short kind=0);
    GQ_ctrl(const GQ_ctrl& other);
    virtual ~GQ_ctrl();
    GQ_ctrl& operator=(const GQ_ctrl& other);
    virtual GQ_ctrl *dup() const override {return new GQ_ctrl(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getCtrl_signal() const;
    virtual void setCtrl_signal(bool ctrl_signal);

    virtual bool getIs_copy() const;
    virtual void setIs_copy(bool is_copy);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GQ_ctrl& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GQ_ctrl& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages/gatedqueue_messages.msg:8</tt> by opp_msgtool.
 * <pre>
 * class NeighborTable
 * {
 *     int neighbor;
 *     string st;
 * }
 * </pre>
 */
class NeighborTable
{
  protected:
    int neighbor = 0;
    ::omnetpp::opp_string st;

  private:
    void copy(const NeighborTable& other);

  protected:
    bool operator==(const NeighborTable&) = delete;

  public:
    NeighborTable();
    NeighborTable(const NeighborTable& other);
    virtual ~NeighborTable();
    NeighborTable& operator=(const NeighborTable& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    virtual int getNeighbor() const;
    virtual void setNeighbor(int neighbor);

    virtual const char * getSt() const;
    virtual void setSt(const char * st);
};

/**
 * Class generated from <tt>messages/gatedqueue_messages.msg:16</tt> by opp_msgtool.
 * <pre>
 * packet Header
 * {
 *     int srcAddr;
 *     int destAddr;
 *     int hopCount;
 * }
 * </pre>
 */
class Header : public ::omnetpp::cPacket
{
  protected:
    int srcAddr = 0;
    int destAddr = 0;
    int hopCount = 0;

  private:
    void copy(const Header& other);

  protected:
    bool operator==(const Header&) = delete;

  public:
    Header(const char *name=nullptr, short kind=0);
    Header(const Header& other);
    virtual ~Header();
    Header& operator=(const Header& other);
    virtual Header *dup() const override {return new Header(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getSrcAddr() const;
    virtual void setSrcAddr(int srcAddr);

    virtual int getDestAddr() const;
    virtual void setDestAddr(int destAddr);

    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Header& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Header& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages/gatedqueue_messages.msg:23</tt> by opp_msgtool.
 * <pre>
 * packet OspfPacket extends Header
 * {
 *     int sending_gate_index \@getter(getSendingGateIndex) \@setter(setSendingGateIndex);
 * }
 * </pre>
 */
class OspfPacket : public ::messages::Header
{
  protected:
    int sending_gate_index = 0;

  private:
    void copy(const OspfPacket& other);

  protected:
    bool operator==(const OspfPacket&) = delete;

  public:
    OspfPacket(const char *name=nullptr, short kind=0);
    OspfPacket(const OspfPacket& other);
    virtual ~OspfPacket();
    OspfPacket& operator=(const OspfPacket& other);
    virtual OspfPacket *dup() const override {return new OspfPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getSendingGateIndex() const;
    virtual void setSendingGateIndex(int sending_gate_index);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>messages/gatedqueue_messages.msg:28</tt> by opp_msgtool.
 * <pre>
 * packet OspfHelloPacket extends OspfPacket
 * {
 *     NeighborTable neighbor_table \@getter(getNeighborTable) \@setter(setNeighborTable);
 * }
 * </pre>
 */
class OspfHelloPacket : public ::messages::OspfPacket
{
  protected:
    NeighborTable neighbor_table;

  private:
    void copy(const OspfHelloPacket& other);

  protected:
    bool operator==(const OspfHelloPacket&) = delete;

  public:
    OspfHelloPacket(const char *name=nullptr, short kind=0);
    OspfHelloPacket(const OspfHelloPacket& other);
    virtual ~OspfHelloPacket();
    OspfHelloPacket& operator=(const OspfHelloPacket& other);
    virtual OspfHelloPacket *dup() const override {return new OspfHelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const NeighborTable& getNeighborTable() const;
    virtual NeighborTable& getNeighbor_tableForUpdate() { return const_cast<NeighborTable&>(const_cast<OspfHelloPacket*>(this)->getNeighborTable());}
    virtual void setNeighborTable(const NeighborTable& neighbor_table);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfHelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfHelloPacket& obj) {obj.parsimUnpack(b);}


}  // namespace messages


namespace omnetpp {

template<> inline messages::GQ_ctrl *fromAnyPtr(any_ptr ptr) { return check_and_cast<messages::GQ_ctrl*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const messages::NeighborTable *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline messages::NeighborTable *fromAnyPtr(any_ptr ptr) { return ptr.get<messages::NeighborTable>(); }
template<> inline messages::Header *fromAnyPtr(any_ptr ptr) { return check_and_cast<messages::Header*>(ptr.get<cObject>()); }
template<> inline messages::OspfPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<messages::OspfPacket*>(ptr.get<cObject>()); }
template<> inline messages::OspfHelloPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<messages::OspfHelloPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __MESSAGES_GATEDQUEUE_MESSAGES_M_H

